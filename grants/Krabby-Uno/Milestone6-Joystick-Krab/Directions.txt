hello! For the next phase of the project, a new Sr. Dev, is going to be working on getting the full end to end robot working in a way that we can joystick the robot to move it forward/back/left/right/turn.

The high level tasks are:
1) Implement a InputController singleton that handles gamepad input over bluetooth/USB and sends to HAL
2) Modify existing ControlLoop and HAL Client/Server code to the new InputController(implementing new GamepadToIsaacSimHALMapper), and modify IsaacSim code to properly send krabby commands to simulation joint positions IsaacSimMCUSDK
3) Bundle as python packages that are built/deployed to pypi (using github hooks and some build standardized build server)
4) Test installation w/ 'pip install krabby-uno krabby-uno-sim' && 'krabby-uno-sim &' && 'krabby-uno krabby-uno --InputController <controllerID> --sim <HAL ID>' and show you can control krabby-uno in simulation using the gamepad
5) Implement GamepadToKrabbyHALMapper, and redo #4 on real HW instead of SIM

----

Here's what I'm thinking for it.:

1) Need to add a Bluetooth controller to the jetson and show that we can issue joystick commands, and that they are received by a new piece of software on the Jetson, called the InputController. The InputController should be stored under a new directory called 'krabby-research/controller/input'. This InputController should be a singleton that gets started by a ControlLoop (in krabby-research/controller/control_loop.py). 

2) The ControlLoop's primary job is to read a configuration for what type of control loop it's supposed to run, i.e. InputController -> HALClient -> IsaacHalServer, or a i.e. ModelController -> HALClient -> KrabbyHalServer -> KrabbyMCUSDK. Use a simple code based configuration for now with those two options. The ControlLoop should then instantiate all the singletons and wire them all up properly (make sure they all have good thread management and constructors that don't require alot of boilerplate).

3) Once the ControlLoop is instantiated, all the main components to run the robot should be working, and in the base case you should be able to joystick up with the a real world bluetooth joystick, and see that joystick input be received by IsaacSim (in IsaacHalServer) and attempt to move the robot in simulation.

4) Debug and get that base case fully working. It will require implementing a HAL mapper to go from the InputController signals (which will be whatever the bluetooth game controller input signal sends) and map those to the individual joint position commands that the robot sees (either in SIM or on the real robot). In this case, lets use some reasonably sensible keymapping, like below.
** NOTE: You will need to manually install a USB bluetooth card and bluetooth drivers on your ubuntu desktop so that you can accept controller input.

Joint selection: 
* Left Trigger - Front Left Leg
* Left Button - Rear Left Leg
* Left Stick Button  - Left Middle Leg
* Right Stick Button - Right Middle Leg
* Right Trigger - Front Right Leg
* Right Button - Rear Right Leg
* LT + LB - FL/RL/MR Legs
* RT + RB - FR/RR/ML Legs

Left Joystick up/down: Hip up/down for all selected legs
Left Joystick left/right: Knee out/in for all selected legs
Right Joystick forward/back: Hip yaw forward/back for all selected legs

With this position, you can manually do a spider-like gait by pressing:
* LT + LB
** move left joystick up/left (to pick up 3x legs by moving hip up and knee out) 
** move right joystick forward (to rotate 3x legs forward while lifted)
* RT + RB
** move right joystick backward (to rotate 3x legs on ground backward, moving robot forward)
* LT + LB
** move left joystick down/right (to move 3x legs back down, all six legs on ground)

Then alternating this gait to continue moving forward: lift leg set -> rotate lifted set forward + rotate ground set backward -> drop leg set


5) Package everything up as proper python packages, so you can just do 'pip install krabby-uno krabby-uno-sim' and it will properly install the full krabby-uno packages on your ubuntu 22.04 desktop, then run 'krabby-uno-sim' on CLI to launch the robot in simulation, 'krabby-uno --InputController <controllerID> --sim <whatever hal needs to communicate/identify w/ SIM>' to launch the krabby uno ControlLoop+HAL+InputController code and attach to the simulator.


6) once you are able to show that you can manually control the robot with a bluetooth game controller in simulation through the HAL, then move onto doing the same thing on the real world robot. In the case of the real world robot, you'll checkout the krabby-research github repo on the Orin on the robot, build the wheels for the HALClient + KrabbyHalServer + ControlLoop + MCUSDK for ARM (or use pre-published versions on pypi, since it's all python code it should not be arm specific, check on current status of package repo)
** NOTE: The goal is this should just be as simple as doing a 'pip install krabby-uno krabby-uno-real' on the orin and all the packages get properly installed.
** NOTE: You will need to manually install a USB bluetooth card and bluetooth drivers on the orin so that the Orin can accept controller input.


Details on GamepadToKrabbyHALMapper:
Every *Controller to *MCUSDK needs to have a mapping function that maps the inputs from the model/gamepad/keyboard/voice/whatever to the control structure expected by that particular hardware/simulation platform. In this case, we are attempting to map Gamepad actions to Krabby joint commands.

Gamepad actions are directly mappable, so something like LT+LS^ (Left Trigger + Left Stick forward) will be handled using python's inputs library, e.g. here's an example InputController code that would need to be built into a full singleton class.

```
from inputs import get_gamepad

# Define button state storage
state = {
    "LT": False,
    "LB": False,
    "LS": False,
    "RS": False,
    "RT": False,
    "RB": False,
    "LX": 0.0,
    "LY": 0.0,
    "RX": 0.0,
    "RY": 0.0,
}

# Function to update state
def update_state(event):
    code = event.code
    val = event.state

    # Analog buttons/triggers and joystick axes vary by controller model.
    # On many controllers:
    #  - Left Trigger: ABS_Z / code "ABS_Z"
    #  - Right Trigger: ABS_RZ / code "ABS_RZ"
    #  - Left Stick Button: BTN_THUMBL / code "BTN_THUMBL"
    #  - Right Stick Button: BTN_THUMBR / code "BTN_THUMBR"
    #  - Left Button: e.g., "BTN_TL" (LB), Right Button "BTN_TR" (RB)
    #  - Left Stick axes: ABS_X, ABS_Y
    #  - Right Stick axes: ABS_RX, ABS_RY

    if code == "ABS_Z":   # Left Trigger analog
        state["LT"] = (val > 10)  # threshold
    elif code == "ABS_RZ":  # Right Trigger analog
        state["RT"] = (val > 10)
    elif code == "BTN_TL":  # Left Button (LB)
        state["LB"] = (val == 1)
    elif code == "BTN_TR":  # Right Button (RB)
        state["RB"] = (val == 1)
    elif code == "BTN_THUMBL":
        state["LS"] = (val == 1)
    elif code == "BTN_THUMBR":
        state["RS"] = (val == 1)

    # Joystick axes
    elif code == "ABS_X":
        state["LX"] = val
    elif code == "ABS_Y":
        state["LY"] = val
    elif code == "ABS_RX":
        state["RX"] = val
    elif code == "ABS_RY":
        state["RY"] = val

def process_controls():
    """Determine leg selections and control axes."""
    # Individual leg selection flags
    select_FL = state["LT"] and not state["LB"]
    select_RL = state["LB"] and not state["LT"]
    select_ML = state["LS"]
    select_MR = state["RS"]
    select_FR = state["RT"] and not state["RB"]
    select_RR = state["RB"] and not state["RT"]

    # Combined selections
    combo_left = state["LT"] and state["LB"]   # FL/RL/MR
    combo_right = state["RT"] and state["RB"]  # FR/RR/ML

    # Build selected legs
    legs = set()
    if combo_left:
        legs |= {"FL", "RL", "MR"}
    if combo_right:
        legs |= {"FR", "RR", "ML"}

    # Single selections if not in combo
    if not combo_left and not combo_right:
        if select_FL: legs.add("FL")
        if select_RL: legs.add("RL")
        if select_ML: legs.add("ML")
        if select_MR: legs.add("MR")
        if select_FR: legs.add("FR")
        if select_RR: legs.add("RR")

    # Movement axes for all selected legs
    if legs:
        hip_up_down = -state["LY"]  # invert if needed
        knee_out_in = state["LX"]
        hip_yaw = state["RY"]
        # TODO: pass legs + hip/knee/hip-yaw through to HALClient, which will call GamepadToKrabbyHALMapper to convert to desired joint position struct and send to simulation (or real robot)

        print(f"Active Legs: {legs}")
        print(f"  Hip up/down: {hip_up_down:.3f}")
        print(f"  Knee out/in: {knee_out_in:.3f}")
        print(f"  Hip yaw: {hip_yaw:.3f}")
        print("-----")
        
    else:
        # No legs selected, do nothing
        pass

print("Listening for gamepad events...")
while True:
    events = get_gamepad()
    for event in events:
        update_state(event)
    process_controls()
```


* Details on IsaacHalServer + IsaacSimMCUSDK:

On krabby-research/hal/server/isaac/hal_server.py:236 apply_command(), is where you receive the joint command from the hal_client, converted by the mapper into the appropriate message structure needed to pass into IsaacSim. Here, it should really just be calling some standardized IsaacSimMCUSDK and handing the command struct to it to move the joints. A simplistic implementation of this is currently in firmware/krabby_mcu.py. This will need to be turned into a real interface and class implementation and is the main work for task #2, creating a simulation version of this same interface, that can take the inputs from the gamepad, run them through the mapper to turn them into appropriate isaacSIM inputs (i.e. the LS/RS values turn into into normalized joint speed values, so that pushing the left stick a little up moves the hip slowly up, while moving it quickly will move the hip up at max motor speed).

* Details on HalClient and wiring to InputController via ControlLoop

right now in hal/client/client.py can send_commands() and receive_observations. In this case the ControlLoop should wire up the InputController so that commands from the inputController singleton get forwarded to the HalClient, with little/no modification through a standardized controller state struct, which the mapper will map into the appropriate backend struct for us automatically. This keeps the code really tight w/ no business logic, it's just passing objects around and handling the thread/singleton/event handling logic. The ONLY place business logic exists: 1) *Controller, which has the gamepad/model specific code that decides how to control the robot, 2) XToYHalMapper, which maps the Gamepad/Model specific input to the backend specific input (and reverse for observations), 3) *MCUSDK, which takes the mapped control structure and moves the robot appropriate (in real life or in SIM). That means whenever you want to make a new robot, you just have to implement the XTo<MYROBOT>Mapper and the <MYROBOT>SDK, and if you want to add a new model, you just have to implement the <MYMODEL>Controller and the <MYMODEL>ToYMappers.

* Details on how to package stuff up for pypi:

1) When implementing the InputController, follow existing examples for the halclient and others for how the pyproject.toml bundles the package(s). 
2) Get an API token from flliver@ for pypi
3) Create a github action workflow that publishes to pypi (follow guides on github/chatgpt)
4) bump pyproject.toml version, and see it auto-publish (lets start with versions 0.1.0 and do minor releases, i.e. 0.1.1+ and continue to 0.1.15+)
5) Make sure to run test targets for InputController, HAL, etc. before publishing package(s), so we don't brick our pypi repo w/ a bad publish